\documentclass{report}
\include{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{	
	\normalfont\normalsize
	\textsc{Πανεπιστήμιο Πατρών, Τμήμα Ηλεκτρολόγων Μηχανικών και Τεχνολογίας Υπολογιστών}\\ % Your university, school and/or department name(s)
	\vspace{25pt} % Whitespace
	\rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
	\vspace{20pt} % Whitespace
	{\huge 3Δ Υπολογιστική Όραση και Γεωμετρία: \\ Signed Distance Function}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	\vspace{12pt} % Whitespace
}

\author{\LARGE Ηλίας Ουζούνης \\ \en{up1083749}} % Your name

\date{\normalsize\today} % Today's date (\today) or a custom date

\begin{document}

\maketitle
\newpage

\sloppy
\tableofcontents
\newpage

\chapter{Εισαγωγή}
Το πρότζεκτ αυτό υλοποιήθηκε στα πλαίσια του μαθήματος 3Δ Υπολογιστική Όραση και Γεωμετρία στο 8ο εξάμηνο στο τμήμα Ηλεκτρολόγων
Μηχανικών και Τεχνολογίας Υπολογιστών του Πανεπιστημίου Πατρών.
\\\\
Σκοπός του πρότζεκτ ήταν η εξοικείωση με το Signed Distance Function ως εναλλακτική μέθοδος περιγραφής ενός 3Δ μοντέλου. 
Συγκεκριμένα δοκιμάστηκε η μέθοδος Ray-Marching για τον έλεγχο τομής του μοντέλου με μία ακτίνα με στόχο τον υπολογισμό
της προβολής του μοντέλου πάνω σε ένα επίπεδο και συκγρίθηκε με μία προσέγγιση χωρίς τη χρήση του Signed Distance Function.
\\\\

\chapter{Part A}
\section{Loading a Watertight Mesh}

Ως watertight mesh, η Open3D ορίζει ένα Mesh το οποίο είναι edge manifold, vertex manifold και όχι self intersecting. Πιο απλά,
ένα watertight mesh είναι ένα mesh που αποτελείται από μία κλειστή επιφάνεια, χωρίς κενά, με ξεκάθαρο μέσα και έξω. 
\\\\
Τα περισσότερα meshes που είναι διαθέσιμα online είναι watertight. Στα πλαίσια τις εργασίας χρησιμοποιήθηκε το μοντέλο ενός αγάλματος γάτας
\cite{concrete-cat-statue}. Περιλαμβάνει 24.4k vertex και 12.0k faces και είναι watertight.
Τα textures του μοντέλου αυτού δεν χρησιμοποιήθηκαν, καθώς δεν είναι απαραίτητα για την εργασία.

\img[Το μοντέλο της γάτας που χρησιμοποιήθηκε]{images/cat-model.png}{20}

\section{Porjection of model onto a plane}
\subsection{Δημιουργία του επιπέδου}

Για να προβληθεί το μοντέλο της γάτας στο επίπεδο, έπρεπε πρώτα να δημιουργηθεί το επίπεδο. Βρίσκοντας το bounding box του μοντέλου
και προσθέτοντας ένα μικρό offset στο z, δημιουργείται το επίπεδο. Το επίπεδο αυτό είναι παράλληλο στο επίπεδο x-y και βρίσκεται πίσω
από το μοντέλο. Για να μπορούν να εμφανιστούν ενδιαφέροντες προβολές, υπάρχει η δυνατότητα περιστροφής του επιπέδου γύρω από τον άξονα y.

\img[Το επίπεδο προβολής πίσω από το μοντέλο]{images/projection-plane.png}{20}

Οι υπολογισμοί που απαιτούνται για την εργασία είναι βοηθητικό να γίνουν στο σύστημα συντεταγμένων του επιπέδου αντί του μοντέλου.
Για τον λόγο αυτό υπολογίστηκε ένα rotation matrix που μεταφέρει το σύστημα συντεταγμένων του μοντέλου στο σύστημα συντεταγμένων του επιπέδου.
Αυτο το rotation matrix υπολογίζεται με βάση το κανονικό διάνυσμα του επιπέδου. Το διάνυσμα πρέπει να περισταφεί ώστε να
πέφτει πάνω στο $\begin{bmatrix}0 \\ 0 \\ 1\end{bmatrix}$. Εδώ χρησιμοποιήθηκε μία τροποποιημένη μορφή του Rodrigues' rotation formula
\cite{rodrigues-rotation-formula}
\begin{align}
    v &= a \times b \notag \\
    K &= \begin{bmatrix}
        0 & -v_z & v_y \\
        v_z & 0 & -v_x \\
        -v_y & v_x & 0
    \end{bmatrix} \notag \\
    \theta &= \arccos(a \cdot b) \notag \\
    R &= I + \sin(\theta)K + (1 - \cos(\theta))K^2
\end{align}
Υπολογίζει τον πίνακα που περιστρέφει το διάνυσμα $a$ στο διάνυσμα $b$. Δηλαδή $Ra = b$. \\
Μαζί με αυτό υπολογίστηκε και το αντίστροφό του $R^{-1}$ για την αντίθετη μετατροπή.

\subsection{Δειγματοληψία του επιπέδου}
Για την ομοιόμορφη δειγματοληψία του επιπέδου χρησιμοποιήθηκε η συνάρτηση create\_random της κλάσσης PointCloud από
την δοθέντη βιβλιοθήκη vvrpywork. Η συνάρτηση όμως, δέχεται σαν όρια για την δειγματοληψία ένα Cuboid. Αν σαν ορίσματα έπαιρνε 2 αντίθετες
κορυφές του επιπέδου, τότε θα επέστρεφε σημεία μέσα στο ορθογώνιο που ορίζουν και όχι μόνο στην επιφάνειά του (όπως απαιτείται).

\img[Λάθος επιλογή τυχαίων σημείων]{images/wrong-point-generation.png}{20}

Εδώ χρειάζεται η αλλαγή του συστήματος συντεταγμένων. Στο σύστημα συντεταγμένων του επιπέδου, το ορθογώνιο που ορίζεται από 2 αντίθετες
κορυφές του ταυτίζεται με το επίπεδο καθώς τα 2 σημεία έχουν τις ίδιες z συντεταγμένες. Έτσι, δημιουργούνται τα σημεία στο σύστημα συντεταγμένων
του επιπέδου και μετατρέπονται έπειτα στο σύστημα συντεταγμένων του μοντέλου για να εμφανιστούν στα σωστά σημεία.
\\\\
Για αυτά τα σημεία, γίνεται ένας έλεγχος αν ανήκουν στην προβολή του επιπέδου ή όχι. Όσα βρίσκονται εντός της προβολής χρωματίζονται με
κόκκινο και τα υπόλοιπα με μαύρο. Στο τέλος, εμφανίζεται με κόκκινο μία προσέγγιση της προβολής του μοντέλου στο επίπεδο. Όσα περισσότερα
σημεία, τόσο καλύτερη η προσέγγιση.

\img[Προσέγγιση της προβολής του μοντέλου στο επίπεδο]{images/projection-point-approximation.png}{20}

\subsection{Υπολογισμός της προβολής}
Ο έλεγχος αν ένα σημείο ανήκει στην προβολή του μοντέλου δεν είναι τόσο απλός. Σε μία πρώτη προσέγγιση, υπολογίζονται οι προβολές των τριγώνων
του μοντέλου στο επίπεδο και ελέγχεται αν το σημείο βρίσκεται εντός κάποιου τριγώνου. Αν βρίσκεται, τότε ανήκει στην προβολή του μοντέλου.
Οι υπολογισμοί γίνονται πάλι στις συντεταγμένες του επιπέδου για ευκολία. Οι κορυφές των τριγώνων μεταφέρονται στο σύστημα συντεταγμένων
του επιπέδου και έπειτα ξεσκαρτάρεται η z συνταταγμένη για να προκύψει η προβολή.
\\\\
Για τον έλεγχο αν ένα σημείο $p$ βρίσκεται εντός ενός τριγώνου χρησιμοποιήθηκαν οι βαρυκεντρικές συντεταγμένες οι οποίες περιγράφουν το
σημείο ως το γραμμικό συνδιαδμό των κορυφών του τριγώνου. 
\begin{align}
    p = u \cdot p_1 + v \cdot p_2 + w \cdot p_3
\end{align}
όπου $p_1, p_2, p_3$ οι κορυφές του τριγώνου και $u, v, w$ οι βαρυκεντρικές συντεταγμένες.\\
Για να βρίσκεται το σημείο μέσα στο τρίγωνο αρκεί να ισχύει 
\begin{align}
    u, v, w \geq 0 \text{ και } u + v + w = 1.
\end{align}
Για τον υπολογισμώ των $u, v, w$ χρησιμοποιήθηκαν οι εξισώσες \cite{barycentric-coordinates}:
\begin{align}\label{barycentric}
    u &= \frac{\begin{vmatrix} 
            p_2.x - p_1.x & p.x - p_1.x \\ 
            p_2.y - p_1.y & p.y - p_1.y 
        \end{vmatrix}}{
        \begin{vmatrix}
            p_2.x - p_1.x & p_3.x - p_1.x \\
            p_2.y - p_1.y & p_3.y - p_1.y
        \end{vmatrix}} \notag \\
    v &= \frac{\begin{vmatrix} 
            p_3.x - p_1.x & p.x - p_1.x \\ 
            p_3.y - p_1.y & p.y - p_1.y 
        \end{vmatrix}}{
        \begin{vmatrix}
            p_2.x - p_1.x & p_3.x - p_1.x \\
            p_2.y - p_1.y & p_3.y - p_1.y
        \end{vmatrix}} \notag \\
    w &= 1 - u - v
\end{align}


\subsection{Επιτάχυνση των υπολογισμών}
Οι υπολογισμοί αυτοί είναι αρκετά αργοί για μεγάλα μοντέλα με πολλά τρίγωνα και πολλά σημεία που χρειάζεται να ελεγχθούν.
Η βιβλιοθήκη numpy βοηθάει στην παραλληλοποίηση πολλών από αυτών των υπολογσμών αξιοποιώντας πολλαπλασιασμούς πινάκων ώστε
αντί να γίνονται οι υπολογισμοί σε κάποιο βρόγχο για κάθε σημείο, γίνονται για όλα τα σημεία ταυτόχρονα.\\
Ορίζεται μία νέα συνάρτηση η οποία παίρνει σαν όρισμα ένα numpy array από σημεία μεγάθους $\left[n, 3\right]$ και επιστρέφει
ένα boolean numpy array $\left[n, m\right]$ όπου $m$ το πλήθος των τριγώνων. Για κάθε σημείο, που αντιστοιχεί σε μία γραμμή στον πίνακα
που επιστρέφεται, αν κάποια τιμή είναι True, σημαίνει ότι πέφτει πάνω στην προβολή κάποιου τριγώνου του μοντέλου. Αν όλες οι τιμές στην γραμμή
είναι False, σημαίνει ότι βρίσκεται εκτός της προβολής.
\\
Επιπλέον, στην εξίσωση υπολογισμού των βαρυκεντρικών συντεταγμένων \eqref{barycentric} κάποες τιμές είναι ανεξάρτητες
του σημείου $p$ που ελέγχεται και μπορούν να προϋπολογιστούν.
\\\\
Ακόμα χρειάζεται ο έλεγχος με όλα τα τρίγωνα του μοντέλου που καθυστερεί σημαντικά τους υπολογισμούς. Για να μειωθούν οι πράξεις που
χρειάζονται, υλοποιήθηκε μία δομή KD-Tree η οποία χωρίζει τα τρίγωνα σε μικρότερες ομάδες ανάλογα με την θέση τους στον χώρο. Έτσι, ένα
σημείο δεν ελέγχεται με τρίγωνα που βρίσκονται πολύ μακριά του.
\\\\
Για την δημιουργία του KD-Tree, δίνονται σαν όρισματα οι προβολές των vertices του μοντέλου στο επίπεδο και ένα indexed list
με τα τρίγωνα. Στον αναδρομικό αλγόριθμο κατασκευής, επιλέγεται ένας άξονας και βρίσκεται το μέσο σημείο των κορυφών επί του άξονα.
Τα σημεία τότε χωρίζονται σε δύο ομάδες ανάλογα με την θέση τους προς τον μέσο. Για τα τρίγωνα θα ισχύει ότι οι κορυφές τους βρίσκονται
αποκλιστηκά στην μία ή στην άλλη ομάδα, ή και στις δύο. Για τα τρίγωνα που όλες τους οι κορυφές βρίσκονται στην ίδια ομάδα, συνεχίζουν
σαν όρισμα στην αναδρομική κλήση. Για αυτά που έχουν κορυφές σε διαφορετικές ομάδες, που τα τέμνει ο άξονας που επιλέχθηκε, αποθηκεύονται
στον κόμβο του δέντρου.


\begin{figure}[H]
    \centering
    \captionsetup{font=small}
    \twoimgs{images/kdtree_3_iters.png}{KD-Tree με 3 iterations}{images/kdtree_5_iters.png}{KD-Tree με 5 iterations}
    \twoimgs{images/kdtree_7_iters.png}{KD-Tree με 7 iterations}{images/kdtree_10_iters.png}{KD-Tree με 10 iterations}
    \captionsetup{font=normal}
    \caption{Σταδιακό χτίσιμο του KD-Tree με τα τρίγωνα σε κάθε κόμβο}
\end{figure}

Οπτικοποιώντας το KD-Tree φαίνονται οι διαφορετικές ομάδες τριγώνων που τέμνονται από την ευθεία που επιλέχθηκε και πώς
δημιουργούνται ανάλογα με το βάθος που έχει φτάσει ο αλγόριθμος.
\\\\
Για τον έλεγχο των σημείων, ξεκινώντας από την ρίζα, ελέγχονται για συγκρούσης με τα τρίγωνα αποθηκευμένα στον κόμβο. Τα σημεία που
βρίκσονται μέσα σε κάποιο από αυτά τα τρίγωνα δεν συνεχίζουν ενώ τα υπόλοιπα χωρίζονται σε δύο ομάδες ανάλογα με την θέση τους
και συνεχίζουν στο αντίστοιχο παιδί. Με αυτόν τον τρόπο, γλυτώνονται πολλές συγκρύσεις τριγώνων-σημείων που δεν χρειάζονται.
\\\\
Αυτή η βελτίωση είναι αισθητή για μεγάλα πλήθη σημείων και τριγώνων. Για τα 12.0k τρίγωνα έγιναν οι ακόλουθες μετρήσεις.
\begin{table}[H]
    \centering
    \begin{tabular}{c||c c}
        Πλήθος σημείων & Χρόνος χωρίς KD-Tree (sec) & Χρόνος με KD-Tree (sec) \\
        \hline
        150 & 0.125 & 0.032 \\
        500 & 0.392 & 0.063 \\
        1000 & 0.765 & 0.097 \\
        5000 & 5.023 & 0.403 \\
        10000 & 11.66 & 0.728 \\
        15000 & Ν/Α & 1.216 \\
    \end{tabular} 
\end{table}

Για 15k σημεία, ο αλγόριθμος χωρίς KD-Tree δεν ολοκληρώθηκε λόγω της μεγάλης πολυπλοκότητας και το πρόγραμμα τερματίστηκε με error.
Αντίθετα, ο αλγόριθμος με KD-Tree ανταπεξήλθε στο απαιτητικό πλήθος σημείων και είχε παντού σημαντικά μικρότερο χρόνο εκτέλεσης.


\clearpage
\selectlanguage{english}
\bibliographystyle{unsrt} % Specify bibliography style
\bibliography{references} % Include your bibliography file (references.bib)

\end{document}
